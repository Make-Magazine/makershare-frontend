var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var fs_1 = require("fs");
var path_1 = require("path");
var mkdirSync = require('mkdir-recursive').mkdirSync;
var file_1 = require("./file");
var exception_1 = require("../../exception");
var type_1 = require("../type");
var base_1 = require("./base");
var PathImpl = (function (_super) {
    __extends(PathImpl, _super);
    function PathImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PathImpl.prototype.exists = function () {
        return this.type() !== type_1.FileType.Unknown;
    };
    PathImpl.prototype.directories = function (predicate) {
        var _this = this;
        this.assert();
        var expr = predicate instanceof RegExp ? predicate : null;
        return new Set(fs_1.readdirSync(this.sourcePath)
            .filter(function (path) { return path !== '.'; })
            .filter(function (path) { return path !== '..'; })
            .filter(function (path) { return expr == null || expr.test(path); })
            .filter(function (path) { return type_1.typeFromPath(path_1.join(_this.sourcePath, path)) === type_1.FileType.Directory; })
            .map(function (path) { return new PathImpl(path_1.normalize(path_1.join(_this.sourcePath, path))); })
            .filter(function (path) { return typeof predicate === 'function' ? predicate(path) : true; }));
    };
    PathImpl.prototype.files = function (predicate) {
        var _this = this;
        this.assert();
        var expr = predicate instanceof RegExp ? predicate : null;
        var owner = this;
        return new Set(fs_1.readdirSync(this.sourcePath)
            .filter(function (file) { return type_1.typeFromPath(path_1.join(_this.sourcePath, file)) === type_1.FileType.File; })
            .filter(function (file) { return expr == null || expr.test(file); })
            .map(function (item) { return new file_1.FileImpl(owner, path_1.normalize(path_1.join(_this.sourcePath, item))); })
            .filter(function (file) { return typeof predicate === 'function' ? predicate(file) : true; }));
    };
    PathImpl.prototype.mkdir = function () {
        try {
            mkdirSync(this.toString());
        }
        catch (exception) {
            throw new exception_1.FilesystemException("Failed to create path: " + this.toString());
        }
    };
    PathImpl.prototype.parent = function () {
        return new PathImpl(path_1.dirname(this.sourcePath));
    };
    PathImpl.prototype.findInAncestor = function (file) {
        this.assert();
        var iterator = this.sourcePath;
        while (path_1.normalize(iterator) !== path_1.normalize(path_1.join(iterator, '..'))) {
            var candidate = path_1.resolve(path_1.normalize(path_1.join(iterator, file)));
            if (fs_1.existsSync(candidate)) {
                switch (type_1.typeFromPath(candidate)) {
                    case type_1.FileType.File:
                        return new file_1.FileImpl(new PathImpl(iterator), candidate);
                    case type_1.FileType.Directory:
                        return new PathImpl(candidate);
                    default:
                        return null;
                }
            }
            iterator = path_1.join(iterator, '..');
        }
        return null;
    };
    PathImpl.prototype.findInChildren = function (file) {
        var traverse = function (node, predicate) {
            return (Array.from(node.files(predicate)).find(function (v) { return true; }) ||
                Array.from(node.directories()).map(function (v) { return traverse(v, predicate); }).find(function () { return true; }));
        };
        return traverse(this, function (path) { return path.name() === file; });
    };
    PathImpl.prototype.unlink = function () {
        for (var _i = 0, _a = Array.from(this.files()).concat(Array.from(this.directories())); _i < _a.length; _i++) {
            var item = _a[_i];
            item.unlink();
        }
        try {
            fs_1.unlinkSync(this.toString());
        }
        catch (exception) { }
    };
    PathImpl.prototype.toString = function () {
        return this.sourcePath;
    };
    PathImpl.prototype.assert = function () {
        if (this.exists() === false) {
            throw new exception_1.FilesystemException("Assertion failed because path does not exist or is not readable: " + this.sourcePath);
        }
    };
    return PathImpl;
}(base_1.FilesystemBaseImpl));
exports.PathImpl = PathImpl;
//# sourceMappingURL=path.js.map