Object.defineProperty(exports, "__esModule", { value: true });
var commander = require("commander");
var chalk = require("chalk");
var path_1 = require("path");
var process_1 = require("process");
var index_1 = require("../../index");
var version = require('../../../package.json').version;
exports.parseCommandLineOptions = function () {
    var options = parseCommandLine();
    var path = index_1.pathFromString(options['project']);
    var tsconfig = tsconfigFromRoot(path);
    if (path.exists() === false) {
        throw new index_1.ConfigurationException("Project path does not exist: " + path);
    }
    var source = options['module'] ? options['module'].replace(/\.(js|ts)$/, String()) : null;
    var symbol = options['symbol'];
    var debug = options['debug'] || false;
    var environment = options['environment'];
    if (environment == null || environment.length === 0) {
        if (debug) {
            environment = 'dev';
        }
        else {
            environment = 'prod';
        }
    }
    var template = index_1.fileFromString(options['template']);
    if (template.exists() === false) {
        throw new index_1.ConfigurationException("HTML template document does not exist: " + options['template']);
    }
    var webpack = options['webpack'];
    var preboot = getPrebootConfiguration(enablePreboot);
    var project = {
        applicationModule: { source: source, symbol: symbol },
        basePath: rootFromTsconfig(tsconfig),
        environment: environment,
        tsconfig: tsconfig,
        workingPath: index_1.pathFromRandomId(),
    };
    var output = createOutput(options);
    return {
        debug: debug,
        output: output,
        pessimistic: pessimistic,
        preboot: preboot,
        project: project,
        templateDocument: template.content(),
        webpack: webpack,
        blacklist: blacklist
    };
};
// Enable preboot integration
var enablePreboot = false;
// Ignore routes that fail to render (just emit warnings instead of failing the process)
var pessimistic = false;
// Inline CSS resources in the compiled HTML output
var inlineStylesheets = true;
// Inline SVG <use xlink:href> instances to deal with absolute paths that wrongly include localhost
var inlineVectorGraphics = false;
// Enable 'blacklist by default' route rendering behaviour (each route you wish to render must be marked with `server: true')
var blacklist = false;
// The name of files to generate for each route (index.html, eg foo/index.html)
var filename = index_1.Files.index;
var renderOptions = function (options) {
    var outputString = options['output'];
    if (/^(\\|\/)/.test(outputString) === false) {
        outputString = path_1.join(process_1.cwd(), outputString);
    }
    var output = index_1.pathFromString(outputString);
    return { filename: filename, output: output, inlineStylesheets: inlineStylesheets, inlineVectorGraphics: inlineVectorGraphics };
};
var createOutput = function (options) {
    return options['ipc']
        ? createInterprocessOutput(renderOptions(options))
        : createHtmlOutput(renderOptions(options));
};
var createInterprocessOutput = function (options) { return new index_1.InterprocessOutput(options); };
var createHtmlOutput = function (options) { return new index_1.HtmlOutput(options); };
var parseCommandLine = function () {
    var options = commander
        .version(version)
        .description(chalk.green('Prerender Angular applications'))
        .option('-e, --environment <environment>', 'Environment selector (dev, prod) (if not specified, will automatically choose based on --debug')
        .option('-d, --debug', 'Enable debugging (stack traces and so forth)', false)
        .option('-p, --project <path>', 'Path to tsconfig.json file or project root (if tsconfig.json lives in the root)', process_1.cwd())
        .option('-w, --webpack <config>', 'Optional path to webpack configuration file')
        .option('-t, --template <path>', 'HTML template document', 'dist/index.html')
        .option('-f, --filename <path>', 'Change the name of the HTML files that are produced', filename)
        .option('-m, --module <path>', 'Path to root application module TypeScript file')
        .option('-s, --symbol <identifier>', 'Class name of application root module')
        .option('-o, --output <path>', 'Output path to write rendered HTML documents to', 'dist')
        .option('-a, --application <applicationID>', 'Optional application ID if your CLI configuration contains multiple apps')
        .option('-P, --preboot [boolean | json-file | json-text]', 'Enable or disable preboot with optional configuration file or JSON text (otherwise automatically find the root element and use defaults)')
        .option('-R, --pessimistic [boolean]', 'Ignore routes that fail to render (just emit warnings, do not fail the whole run)')
        .option('-i, --inline [boolean]', 'Inline of resources referenced in links')
        .option('-S, --inline-svg [boolean]', 'Inline SVG <use xlink:href> instances (to resolve issues with absolute URI SVG identifiers eg http://localhost/#foo')
        .option('-I, --ipc', 'Send rendered documents to parent process through IPC instead of writing them to disk', false)
        .option('-b, --blacklist [boolean]', 'Blacklist all routes by default such that all routes which should be rendered must be specially marked with "server: true" in the route definition', false);
    options.on('preboot', function (value) { return enablePreboot = value == null ? true : value; });
    options.on('inline', function (value) { return inlineStylesheets = value == null ? true : value; });
    options.on('inline-svg', function (value) { return inlineVectorGraphics = value == null ? true : value; });
    options.on('blacklist', function (value) { return blacklist = value == null ? true : value; });
    options.on('pessimistic', function (value) { return pessimistic = value == null ? true : value; });
    options.on('filename', function (value) { return filename = value; });
    return options.parse(process.argv);
};
var rootFromTsconfig = function (tsconfig) {
    var parsed = index_1.fromJson(tsconfig.content());
    if (parsed.compilerOptions) {
        var root = parsed.compilerOptions.baseUrl || parsed.compilerOptions.sourceRoot;
        if (root) {
            return index_1.pathFromString(index_1.makeAbsolute(tsconfig.parent(), root));
        }
    }
    return tsconfig.parent();
};
var tsconfigFromRoot = function (fromRoot) {
    if (fromRoot.exists() === false) {
        throw new index_1.ConfigurationException("Root path does not exist: " + fromRoot);
    }
    if (fromRoot.type() === index_1.FileType.File) {
        return index_1.fileFromString(fromRoot.toString());
    }
    var _loop_1 = function (tsc) {
        var candidates = Array.from(fromRoot.directories()).concat(fromRoot)
            .filter(function (p) { return /(\\|\/)e2e(\\|\/)/.test(p.toString()) === false; });
        var found = candidates.map(function (d) { return index_1.fileFromString(path_1.join(d.toString(), tsc)); }).find(function (c) { return c.exists(); });
        if (found) {
            return { value: found };
        }
    };
    for (var _i = 0, _a = index_1.Files.tsconfig; _i < _a.length; _i++) {
        var tsc = _a[_i];
        var state_1 = _loop_1(tsc);
        if (typeof state_1 === "object")
            return state_1.value;
    }
    return null;
};
var getPrebootConfiguration = function (filenameOrJson) {
    if (typeof filenameOrJson !== 'string') {
        return filenameOrJson == null ? false : filenameOrJson;
    }
    switch (filenameOrJson) {
        case 'true':
        case 'false':
        case '':
            return filenameOrJson !== 'false';
        default:
            return parsePreboot(filenameOrJson);
    }
};
var parsePreboot = function (json) {
    var options;
    if (json.trim().startsWith('{')) {
        try {
            options = index_1.fromJson(json);
        }
        catch (exception) {
            throw new index_1.ConfigurationException('Preboot configuration: invalid JSON document', exception);
        }
    }
    else if (json.length > 0) {
        var file = index_1.absoluteFile(process_1.cwd(), json);
        if (file.exists() === false || file.type() !== index_1.FileType.File) {
            throw new index_1.ConfigurationException("Preboot configuration file does not exist or is not a file: " + file.toString());
        }
        options = index_1.fromJson(file.content());
    }
    else {
        return true;
    }
    var validation = index_1.validatePrebootOptionsAgainstSchema(options);
    if (validation.errors.length > 0) {
        throw new index_1.ConfigurationException("Preboot configuration " + json + " is invalid: " + validation.toString());
    }
    return options;
};
//# sourceMappingURL=parse.js.map