var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var _this = this;
Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = require("@angular/common");
var router_1 = require("@angular/router");
var static_1 = require("../static");
var platform_1 = require("../platform");
var transform_1 = require("./transform");
var application_1 = require("../platform/application");
exports.applicationRoutes = function (operation) {
    var platform = operation.platform, moduleFactory = operation.moduleFactory, templateDocument = operation.templateDocument;
    // NOTE(bond): The way that we attempt to extract routes from an NgModuleFactory is to actually
    // instantiate the application and then query the configuration from the Router module. This is
    // cleaner and much easier than attempting to collect all the routes from every @NgModule in the
    // application, including lazily loaded modules. And because we only ever have to do it once (to
    // discover the routes), there is no negative performance impact except maybe startup time.
    //
    // One kink of this approach is that some applications put complex operations inside their module
    // constructors. For example, it's fairly common to see an NgModule which kicks off an HTTP request
    // inside of its constructor (or indirectly, in a function called from the constructor). So even
    // though we really don't want to do a complete bootstrap and render, we have to wait for those
    // operations to finish and for the zone to stabilize before we can destroy the module instance.
    // Otherwise those asynchronous operations will have the rug pulled from under them and cause
    // all kinds of nasty console errors.
    var execute = function () { return __awaiter(_this, void 0, void 0, function () {
        var moduleRef, promises, stable;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, platform.bootstrapModuleFactory(moduleFactory)];
                case 1:
                    moduleRef = _a.sent();
                    promises = [
                        application_1.waitForRouterNavigation(moduleRef),
                        application_1.waitForApplicationToBecomeStable(moduleRef)
                    ];
                    stable = Promise.all(promises);
                    stable.then(function () { return moduleRef.destroy(); });
                    return [2 /*return*/, extractRoutesFromModule(moduleRef)];
            }
        });
    }); };
    return platform_1.forkZoneExecute(templateDocument, static_1.ApplicationFallbackOptions.fallbackUri, execute);
};
exports.extractRoutesFromRouter = function (router, location) {
    var empty = new Array();
    if (router == null ||
        router.config == null ||
        router.config.length === 0) {
        return empty;
    }
    var flatten = function (parent, routes) {
        return routes.reduce(function (prev, route) {
            var prepared = location.prepareExternalUrl(parent.concat(route.path || []).join('/'));
            var path = prepared.replace(/(^\.|\*\*?)/g, String()).split(/\//g).filter(function (v) { return v; });
            return prev.concat({ path: path, server: route.server }, flatten(path, route.children || []));
        }, empty);
    };
    return exports.uniqueRoutes(flatten(new Array(), router.config));
};
var singleRoute = { path: [] };
var extractRoutesFromModule = function (moduleRef) {
    var router = moduleRef.injector.get(router_1.Router, null);
    if (router == null) {
        return [singleRoute];
    }
    var location = moduleRef.injector.get(common_1.Location);
    return exports.extractRoutesFromRouter(router, location);
};
exports.renderableRoutes = function (routes) {
    var isParameter = function (segment) { return segment.startsWith(':'); };
    var unrenderable = new Set(routes.filter(function (_a) {
        var path = _a.path;
        return path.some(isParameter);
    }));
    return routes.filter(function (r) { return unrenderable.has(r) === false; });
};
exports.uniqueRoutes = function (routes) {
    var map = new Map();
    for (var _i = 0, routes_1 = routes; _i < routes_1.length; _i++) {
        var r = routes_1[_i];
        map.set(transform_1.routeToPathWithParameters(r), r);
    }
    return Array.from(map.values());
};
//# sourceMappingURL=extract.js.map