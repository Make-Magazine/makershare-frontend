Object.defineProperty(exports, "__esModule", { value: true });
var typescript_1 = require("typescript");
var chalk = require("chalk");
var exception_1 = require("../../../exception");
var find_1 = require("../find");
var static_1 = require("../../../static");
var predicates_1 = require("../predicates");
var traverse_1 = require("../traverse");
exports.discoverRootModule = function (basePath, program) {
    var identifiers = Object.keys(static_1.BootstrapFunctions).map(function (k) { return static_1.BootstrapFunctions[k]; }).join('|');
    var expression = new RegExp("(." + identifiers + ")");
    var candidates = new Array();
    var _loop_1 = function (sourceFile) {
        if (predicates_1.isExternalModule(sourceFile) || expression.test(sourceFile.text) === false) {
            return "continue";
        }
        var bootstrapIdentifiers = new Set();
        traverse_1.traverse(sourceFile, typescript_1.SyntaxKind.CallExpression, function (node) {
            if (node.expression.kind !== typescript_1.SyntaxKind.PropertyAccessExpression) {
                return false;
            }
            var pae = node.expression;
            if (pae.name.kind !== typescript_1.SyntaxKind.Identifier) {
                return false;
            }
            switch (pae.name.text) {
                case static_1.BootstrapFunctions.bootstrap:
                case static_1.BootstrapFunctions.bootstrapFactory:
                    if (node.arguments.length === 0 || node.arguments[0].kind !== typescript_1.SyntaxKind.Identifier) {
                        break;
                    }
                    bootstrapIdentifiers.add(node.arguments[0].text);
                    return true;
            }
            return false;
        });
        for (var _i = 0, _a = Array.from(bootstrapIdentifiers); _i < _a.length; _i++) {
            var identifier = _a[_i];
            var imported = find_1.importClause(basePath.toString(), sourceFile, identifier);
            if (imported) {
                candidates.push(imported);
            }
            else {
                var declaration = find_1.exportClause(basePath.toString(), sourceFile, identifier);
                if (declaration) {
                    var descriptions = [
                        'Pairing bootstrapModule or bootstrapModuleFactory with the root @NgModule in the same file will not work',
                        'Otherwise it is impossible to import that module without bootstrapping the application',
                        "You must extract \"" + identifier + "\" from " + sourceFile.fileName + " and export it from a separate file for this to work"
                    ];
                    throw new exception_1.StaticAnalysisException(chalk.red(descriptions.join('\n')));
                }
            }
        }
    };
    for (var _i = 0, _a = program.getSourceFiles(); _i < _a.length; _i++) {
        var sourceFile = _a[_i];
        _loop_1(sourceFile);
    }
    switch (candidates.length) {
        case 0:
            throw new exception_1.StaticAnalysisException('No root @NgModule discovered (an NgModule which is passed to a bootstrap function) (use the CLI or API options instead)');
        case 1:
            return candidates[0];
        default:
            throw new exception_1.StaticAnalysisException("Multiple root @NgModule discovered, cannot determine the correct one (" + candidates.map(function (m) { return m.symbol + " in " + m.source; }).join(', and ') + ")");
    }
};
//# sourceMappingURL=root.js.map